"""
Encryption utilities for sensitive data at rest.

Uses Fernet (symmetric encryption) with a dedicated encryption key.
"""

import threading
from cryptography.fernet import Fernet
import base64
import binascii
from .config import settings

# Cache the Fernet instance to avoid recreating it on every call
_fernet_instance: Fernet | None = None
# Track the key string used to create the cached instance for invalidation
_cached_key_str: str | None = None
# Module-level lock to ensure thread-safe lazy initialization of the Fernet instance
_fernet_lock = threading.Lock()


def _get_fernet_key() -> bytes:
    """
    Return the configured Fernet key as bytes.
    Key must be a base64 URL-safe 32-byte string (as generated by Fernet.generate_key()).
    """
    key_str = (settings.encryption_key or "").strip()
    try:
        decoded = base64.b64decode(key_str.encode("utf-8"), altchars=b"-_", validate=True)
    except (binascii.Error, ValueError) as exc:
        raise ValueError("Invalid encryption_key: must be URL-safe base64-encoded 32-byte key") from exc
    if len(decoded) != 32:
        raise ValueError("Invalid encryption_key: decoded key must be 32 bytes")
    # Return the original base64-encoded key bytes (what Fernet() expects)
    return key_str.encode("utf-8")


def _get_fernet() -> Fernet:
    """Get or create the Fernet instance (cached).
    Thread-safe lazy initialization using double-checked locking.
    Invalidates cache if settings.encryption_key has changed at runtime.
    """
    global _fernet_instance, _cached_key_str
    
    # Fast path: return cached instance if available and key unchanged
    current_key_str = (settings.encryption_key or "").strip()
    if _fernet_instance is not None and _cached_key_str == current_key_str:
        return _fernet_instance
    
    # Slow path: acquire lock and re-check (double-checked locking)
    with _fernet_lock:
        # Re-check under lock in case another thread just initialized
        current_key_str = (settings.encryption_key or "").strip()
        
        # Check if key has changed (reacts to runtime settings updates)
        if _fernet_instance is not None and _cached_key_str is not None:
            if current_key_str != _cached_key_str:
                # Key changed, invalidate cache
                _fernet_instance = None
                _cached_key_str = None
        
        # Create instance if needed
        if _fernet_instance is None:
            key = _get_fernet_key()
            _fernet_instance = Fernet(key)
            _cached_key_str = current_key_str
        
        return _fernet_instance


def encrypt(text: str | None) -> str | None:
    """
    Encrypt a plaintext string.
    
    Args:
        text: Plaintext string to encrypt. If None, returns None without encryption.
        
    Returns:
        Encrypted string (base64-encoded). Returns None if input is None.
        
    Behavior:
        Empty strings are encrypted (not passed through). Treating empty strings as
        normal input avoids leaking presence/absence of data and keeps symmetry
        with decryption.
    
    Raises:
        Exception: If encryption fails
    """
    if text is None:
        return None
    fernet = _get_fernet()
    encrypted_bytes = fernet.encrypt(text.encode('utf-8'))
    return encrypted_bytes.decode('utf-8')


def decrypt(encrypted_text: str | None) -> str | None:
    """
    Decrypt an encrypted string.
    
    Args:
        encrypted_text: Encrypted string (base64-encoded). If None, returns None.
        
    Returns:
        Decrypted plaintext string. Returns None if input is None.
        
    Behavior:
        Empty strings are decrypted (not passed through) to maintain symmetry with
        encryption and avoid leaking presence/absence of data.
    
    Raises:
        Exception: If decryption fails (e.g., invalid token, tampered data)
    """
    if encrypted_text is None:
        return None
    fernet = _get_fernet()
    decrypted_bytes = fernet.decrypt(encrypted_text.encode('utf-8'))
    return decrypted_bytes.decode('utf-8')
