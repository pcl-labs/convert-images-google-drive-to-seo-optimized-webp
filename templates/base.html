<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{ title or 'App' }}</title>
    <link rel="stylesheet" href="{{ url_for('static', path='css/app.css') }}">
    <style>[x-cloak]{display:none !important;}</style>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://unpkg.com/htmx.org@1.9.12"></script>
    <script>
      window.__modalOpen = false;
      window.addEventListener('open-drive-disconnect', function(){ window.__modalOpen = true; });
      window.addEventListener('confirm-drive-disconnect', function(){ window.__modalOpen = false; });
      window.addEventListener('close-drive-disconnect', function(){ window.__modalOpen = false; });

      window.modalState = function(id){
        return {
          open: false,
          prevEl: null,
          titleId: `modal-title-${id}`,
          trap(e){
            if(!this.open) return;
            const focusables = this.$root.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            const els = Array.from(focusables).filter(el => !el.hasAttribute('disabled') && el.offsetParent !== null);
            if(!els.length) return;
            const first = els[0];
            const last = els[els.length - 1];
            if(e.key === 'Tab'){
              if(e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
              else if(!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
            }
          },
          openModal(){
            this.prevEl = document.activeElement;
            if(document.body){ document.body.style.overflow = 'hidden'; }
            this.$nextTick(() => {
              const focusTarget = this.$root.querySelector('[data-autofocus]') || this.$root.querySelector('[role="dialog"]') || this.$root;
              focusTarget && focusTarget.focus && focusTarget.focus();
            });
          },
          closeModal(){
            if(document.body){ document.body.style.overflow = ''; }
            this.open = false;
            this.prevEl && this.prevEl.focus && this.prevEl.focus();
          }
        };
      };

      document.addEventListener('DOMContentLoaded', () => {
        const bodyEl = document.body;
        if (bodyEl) {
          bodyEl.addEventListener('htmx:error', function(){
            window.dispatchEvent(new CustomEvent('toast', { detail: { type: 'error', text: 'Request failed' } }));
          });
        }

        // Notifications via SSE (replace polling)
        try {
          window.__notifiedIds = new Set();
          // simple fixed-size hash (FNV-1a 32-bit) for dedupe key
          function hashKey(str){
            let h = 0x811c9dc5;
            for (let i = 0; i < str.length; i++) {
              h ^= str.charCodeAt(i);
              h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
            }
            return ('00000000' + h.toString(16)).slice(-8);
          }
          let retryDelay = 1000; // start 1s
          const maxDelay = 30000; // cap at 30s
          function openES(){
            const es = new EventSource('/api/stream');
            es.onopen = () => {
              // reset backoff once the connection is successfully open
              retryDelay = 1000;
            };
            es.onmessage = (evt) => {
              try {
                const msg = JSON.parse(evt.data || '{}');
                if (msg && msg.type === 'notification.created' && msg.data) {
                  const n = msg.data;
                  const key = hashKey(`${n.id}:${n.level}:${n.text || ''}`);
                  if (window.__notifiedIds.has(key)) return;
                  window.__notifiedIds.add(key);
                  const type = n.level === 'error' ? 'error' : (n.level === 'success' ? 'success' : 'info');
                  window.dispatchEvent(new CustomEvent('toast', { detail: { type, text: n.text } }));
                }
              } catch (e) {
                if (console && console.error) console.error('SSE onmessage error', e);
              }
            };
            es.onerror = (e) => {
              if (console && console.error) console.error('SSE connection error', e);
              try { es.close(); } catch(_) {}
              window.dispatchEvent(new CustomEvent('toast', { detail: { type: 'error', text: 'Live updates disconnected, retrying...' } }));
              window.__es = null;
              setTimeout(() => {
                retryDelay = Math.min(maxDelay, retryDelay * 2);
                openES();
              }, retryDelay);
            };
            window.__es = es;
          }
          openES();
          // Close on unload to avoid leaked connections
          window.addEventListener('beforeunload', () => { try { window.__es && window.__es.close(); } catch(_) {} });
          window.addEventListener('unload', () => { try { window.__es && window.__es.close(); } catch(_) {} });
        } catch (e) {
          if (console && console.error) console.error('SSE init error', e);
        }
      });
    </script>
  </head>
  <body class="dark">
    <div class="min-h-screen bg-slate-950">
      {% include 'components/layout/sidebar.html' %}
      <div class="lg:pl-64 pt-14 lg:pt-0">
        <main>
          <div id="flash-area">{% block flash %}{% endblock %}</div>
          {% block content %}{% endblock %}
        </main>
      </div>
      {% include 'components/overlays/toast.html' %}
    </div>
  </body>
</html>
